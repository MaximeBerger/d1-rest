<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Enregistrer un score par thème</title>
  <style>
    :root { --bg:#0b1020; --card:#121934; --ink:#e8ecff; --sub:#9aa5d1; --accent:#7aa2ff; --good:#1fbf75; --bad:#f25757; }
    html,body{height:100%;}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:radial-gradient(1200px 800px at 10% -10%, #1b2558 0, rgba(27,37,88,0) 60%),
      radial-gradient(1000px 700px at 100% 0, #163a63 0, rgba(22,58,99,0) 60%), var(--bg); color:var(--ink);}
    .container{max-width:720px; margin:40px auto; padding:0 16px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border:1px solid rgba(255,255,255,0.08);
      border-radius:16px; padding:20px 20px 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.25);}
    h1{font-size:1.4rem; margin:0 0 4px;}
    p.sub{color:var(--sub); margin:0 0 18px;}
    form{display:grid; gap:14px;}
    .row{display:grid; grid-template-columns:1fr 1fr; gap:12px;}
    label{font-size:.9rem; color:var(--sub); margin-bottom:6px; display:block;}
    input, select{width:100%; padding:12px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.03); color:var(--ink); outline:none;}
    input:focus, select:focus{border-color:var(--accent); box-shadow:0 0 0 3px rgba(122,162,255,.2)}
    .actions{display:flex; gap:10px; align-items:center;}
    button{padding:12px 16px; border:none; border-radius:12px; color:white; background:var(--accent); font-weight:600; cursor:pointer;}
    button[disabled]{opacity:.6; cursor:not-allowed}
    .muted{color:var(--sub); font-size:.9rem}
    .badge{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; font-size:.85rem; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08)}
    .ok{color:var(--good)} .err{color:var(--bad)}
    .toast{position:fixed; right:16px; bottom:16px; background:#11183a; border:1px solid rgba(255,255,255,0.12); color:var(--ink); padding:12px 14px; border-radius:12px; box-shadow:0 12px 30px rgba(0,0,0,.35); opacity:0; transform: translateY(10px); transition:.2s;}
    .toast.show{opacity:1; transform: translateY(0)}
    code.inline{background:rgba(255,255,255,0.08); padding:2px 6px; border-radius:6px}
    .help{margin-top:10px; font-size:.9rem}
    .footer{margin-top:16px; display:flex; justify-content:space-between; align-items:center;}
    .api{font-size:.85rem; color:var(--sub)}
    .api a{color:var(--ink)}
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Enregistrer un score par thème</h1>
      <p class="sub">Template minimal pour POSTer vers votre Worker Cloudflare (API REST D1).</p>

      <form id="scoreForm">
        <div>
          <label for="external_id">Identifiant étudiant <span class="muted">(ex. <code class="inline">etu_001</code>)</span></label>
          <input id="external_id" name="external_id" required autocomplete="username" />
        </div>
        <div class="row">
          <div>
            <label for="theme_code">Code thème <span class="muted">(ex. <code class="inline">PROBA</code>)</span></label>
            <input id="theme_code" name="theme_code" required />
          </div>
          <div>
            <label for="max_score">Barème (max)</label>
            <input id="max_score" name="max_score" type="number" min="0.01" step="0.01" required />
          </div>
        </div>
        <div class="row">
          <div>
            <label for="score">Score obtenu</label>
            <input id="score" name="score" type="number" min="0" step="0.01" required />
          </div>
          <div>
            <label for="session_code">Session (optionnel)</label>
            <input id="session_code" name="session_code" placeholder="QCM_PROBA_S1_2025" />
          </div>
        </div>
        <div class="actions">
          <button id="submitBtn" type="submit">Enregistrer</button>
          <span id="pctBadge" class="badge">% calculé : <strong id="pctVal">—</strong></span>
        </div>
        <div class="help muted">
          <div>Endpoint attendu (modifiable dans <code class="inline">API_ENDPOINT</code>) : <code class="inline">POST /api/scores</code></div>
          <div>Payload JSON : <code class="inline">{ external_id, theme_code, score, max_score, session_code? }</code></div>
        </div>
      </form>

      <div class="footer">
        <div class="api">Astuce : la dernière cible API est mémorisée dans le stockage local.</div>
        <div>
          <label for="api_endpoint" class="muted">API</label>
          <input id="api_endpoint" style="width:320px" placeholder="/api/scores" />
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    // === Réglages ===
    const endpointInput = document.getElementById('api_endpoint');
    const savedEndpoint = localStorage.getItem('api_endpoint') || '/api/scores';
    endpointInput.value = savedEndpoint;

    function setToast(msg, ok = true){
      const t = document.getElementById('toast');
      t.textContent = msg; t.classList.toggle('show', true); t.style.borderColor = ok ? 'rgba(31,191,117,.6)' : 'rgba(242,87,87,.6)';
      setTimeout(()=> t.classList.remove('show'), 2600);
    }

    // % calculé
    const scoreEl = document.getElementById('score');
    const maxEl   = document.getElementById('max_score');
    const pctEl   = document.getElementById('pctVal');

    function refreshPct(){
      const s = parseFloat(scoreEl.value);
      const m = parseFloat(maxEl.value);
      if(!isFinite(s) || !isFinite(m) || m <= 0){ pctEl.textContent = '—'; return; }
      const p = Math.max(0, Math.min(100, (s/m)*100));
      pctEl.textContent = p.toFixed(2) + '%';
    }
    scoreEl.addEventListener('input', refreshPct);
    maxEl.addEventListener('input', refreshPct);

    // Soumission
    document.getElementById('scoreForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const btn = document.getElementById('submitBtn');
      const external_id = document.getElementById('external_id').value.trim();
      const theme_code  = document.getElementById('theme_code').value.trim();
      const score       = parseFloat(document.getElementById('score').value);
      const max_score   = parseFloat(document.getElementById('max_score').value);
      const session_code= document.getElementById('session_code').value.trim() || null;

      if(!external_id || !theme_code || !isFinite(score) || !isFinite(max_score) || max_score <= 0){
        setToast('Champs invalides', false); return;
      }

      const API_ENDPOINT = endpointInput.value.trim() || '/api/scores';
      localStorage.setItem('api_endpoint', API_ENDPOINT);

      const payload = { external_id, theme_code, score, max_score, session_code };

      try{
        btn.disabled = true; btn.textContent = 'Enregistrement…';
        const res = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        const data = await res.json().catch(()=> ({}));

        if(!res.ok){
          const msg = data?.error || res.status + ' ' + res.statusText;
          setToast('Erreur: ' + msg, false);
        } else {
          const pct = (score/max_score*100).toFixed(2);
          setToast(`OK — ${external_id} · ${theme_code} = ${score}/${max_score} (${pct}%)`);
          e.target.reset(); refreshPct();
        }
      } catch (err){
        setToast('Erreur réseau: ' + err.message, false);
      } finally {
        btn.disabled = false; btn.textContent = 'Enregistrer';
      }
    });
  </script>

  <!--
  ===============================
  Exemple d’API (Worker Cloudflare)
  ===============================

  // wrangler.toml
  // [[d1_databases]]
  // binding = "DB"
  // database_name = "qcm_db"
  // database_id = "..."

  export default {
    async fetch(request, env) {
      const url = new URL(request.url);
      if (url.pathname === '/api/scores' && request.method === 'POST') {
        try {
          const body = await request.json();
          const { external_id, theme_code, score, max_score, session_code } = body;

          if (!external_id || !theme_code || !(max_score > 0) || !(score >= 0)) {
            return json({ error: 'Champs invalides' }, 400);
          }

          // Création référentiels
          await env.DB.exec(`CREATE TABLE IF NOT EXISTS students (id INTEGER PRIMARY KEY AUTOINCREMENT, external_id TEXT UNIQUE);`);
          await env.DB.exec(`CREATE TABLE IF NOT EXISTS themes (id INTEGER PRIMARY KEY AUTOINCREMENT, code TEXT UNIQUE NOT NULL);`);
          await env.DB.exec(`CREATE TABLE IF NOT EXISTS quiz_sessions (id INTEGER PRIMARY KEY AUTOINCREMENT, code TEXT UNIQUE NOT NULL);`);
          await env.DB.exec(`CREATE TABLE IF NOT EXISTS student_theme_scores (
            student_id INTEGER NOT NULL,
            theme_id   INTEGER NOT NULL,
            session_id INTEGER,
            score      REAL NOT NULL,
            max_score  REAL NOT NULL,
            updated_at TEXT NOT NULL DEFAULT (datetime('now')),
            PRIMARY KEY (student_id, theme_id, session_id),
            FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
            FOREIGN KEY (theme_id) REFERENCES themes(id) ON DELETE CASCADE,
            FOREIGN KEY (session_id) REFERENCES quiz_sessions(id) ON DELETE SET NULL
          );`);

          const tx = await env.DB.batch([
            env.DB.prepare(`INSERT OR IGNORE INTO students(external_id) VALUES (?)`).bind(external_id),
            env.DB.prepare(`INSERT OR IGNORE INTO themes(code) VALUES (?)`).bind(theme_code),
            session_code ? env.DB.prepare(`INSERT OR IGNORE INTO quiz_sessions(code) VALUES (?)`).bind(session_code) : null,
          ].filter(Boolean));

          // Récupérer les ids
          const s = await env.DB.prepare(`SELECT id FROM students WHERE external_id=?`).bind(external_id).first();
          const t = await env.DB.prepare(`SELECT id FROM themes   WHERE code=?`).bind(theme_code).first();
          const q = session_code ? await env.DB.prepare(`SELECT id FROM quiz_sessions WHERE code=?`).bind(session_code).first() : null;

          // UPSERT (SQLite modern ≥3.24 ; D1 est compatible)
          await env.DB.prepare(`
            INSERT INTO student_theme_scores (student_id, theme_id, session_id, score, max_score, updated_at)
            VALUES (?, ?, ?, ?, ?, datetime('now'))
            ON CONFLICT(student_id, theme_id, session_id)
            DO UPDATE SET score=excluded.score, max_score=excluded.max_score, updated_at=datetime('now');
          `).bind(s.id, t.id, q?.id ?? null, score, max_score).run();

          return json({ ok: true, external_id, theme_code, score, max_score, session_code: session_code ?? null });
        } catch (e) {
          return json({ error: e.message }, 500);
        }
      }
      return new Response('Not found', { status: 404 });

      function json(data, status=200){
        return new Response(JSON.stringify(data), { status, headers: { 'Content-Type': 'application/json' }});
      }
    }
  }

  -->
</body>
</html>
